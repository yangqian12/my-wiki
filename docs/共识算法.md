### 共识算法

---

多副本保证了可靠性，而一致性需要靠 paxos 这类分布式一致性算法来保证。



#### 基础复制算法

- 主从异步复制。是最简单的策略之一，但是有丢失数据的风险，不是一个可靠的策略。如 mysql 的 binlog 复制。
- 主从同步复制。直到数据复制到所有机器上后，master 应答。提供了完整的可靠性但是可用性降低。
- 半同步复制。master 在应答客户端之前将数据复制到足够多的机器上。可靠性提高但是有不一致的问题。
- 多数派写（读）。半数以上。带时间戳。



#### 多数派写的问题

1. 并发冲突。一个客户端的写覆盖另一个客户端的写。写前读取，记住谁最后一个做过写前读取（类似逻辑锁），并只允许最后一个做过写前读取的进程可以进行写入。
2. 如何确认谁是最后一个完成写前读取的进程。



#### Paxos 算法描述

##### paxos 是什么

- 一个可靠的存储系统：基于多数派读写
- 每个 paxos 实例用来存储一个值
- 用两轮 rpc 来确定一个值
- 一个值确定后不能被修改
- ‘确定’ 指被多数派接受写入
- 强一致性

##### 基于 paxos 的优化

- classic paxos。一个实例写入需要两轮 rpc
- Multi paxos。约为一轮 rpc 确定一个值。
- fast paxos。没冲突一轮 rpc 确定一个值，有冲突两轮 rpc 确定一个值。



##### 一些概念

- Proposer。客户端，发起 paxos 进程。
- Acceptor。存储节点。
- Quorum。多数派，n/2 + 1 个 Acceptors。
- Round。一轮包含2个阶段：phase-1 & phase-2。每一轮的编号(rnd): 单调递增；后写胜出；全局唯一。

##### 存储端概念

- last_rnd。最后一次进行写前读取的 Proposer。
- v。最后被写入的值。
- vrnd。跟 v 是一对，记录在哪个 round 中 v 被写入。

##### phase-1

当 Proposer 收到 Acceptor 发回的应答。

- 如果应答中的 last_rnd 大于发出的 rnd: 退出。
- 从所有应答中选出 vrnd 最大的 v：不能改变（可能）已经确定的值
- 如果所有应答 v 都是空，可以选择自己要写入 v。
- 如果应答不够多数派，退出。

##### phase-2

Acceptor

- 拒绝 rnd 不等于 Acceptor 的 last_rnd 的请求。
- 将 phase-2 请求中的 v 写入本地，记此 v 为‘已接受的值’
- last_rnd == rnd 保证没有其它 Proposer 在此过程中写如果其它值。

##### 其它

Learner 角色：

- Acceptor 发送 phase-3 到所有 Learner 角色，让 Learner 知道一个值被确定了。
- 多数场合 Proposer 就是一个 Learner。

Livelock



#### Paxos 优化

##### multi-paxos

将多个 Paxos 实例的 phase-1 合并到一个 rpc，使得这些 paxos 只需要运行 phase-2 即可。

##### fast-paxos

通过增加 quorum 的数量来达到一次 rpc 就能达成一致的目的。如果 fast-paxos 没能在一次 rpc 达成一致，就要退化成 classic-paxos。

##### fast-paxos 中的多数派

- Q = (3/4)*n
- 可用性降低，需要更多的 Acceptor 来工作
- 至少需要5个 Acceptor ，才能容忍一个 Acceptor 不可用



#### Raft 算法

管理多副本状态机的日志复制

- leader。接受客户端请求，并向 follower 同步请求日志。当日志同步到大多数节点后告诉 follower 提交日志。
- follower。接受并持久化 leader 同步的日志，在 leader 告知日志可以提交后，提交日志。
- candidate。leader 选举过程中的临时角色。

raft 要求系统在任意时刻至多只有一个 leader。正常工作期间只有 leader 和 follower。



##### leader 选举

如果 follower 在选举超时时间内没有收到 leader 的 heartbeat，就会触发选举。

follower 将当前 term 加 1 然后转换为 candidate。它首先给自己投票然后向其它服务器发送 RequestVote RPC。

结果

- 赢得多数投票，成为 leader。
- 收到 leader 消息，表示已有其它服务器被选举成为 leader。
- 没有服务器当选，leader 选举失败，等待选举时间超时进行下一次选举。

##### 日志同步

选举出的 leader 一定具有最新的已提交的日志。leader 将请求作为日志条目（log entries）加入到它的日志中。然后并行的向其它服务器发起 AppendEntries RPC 复制日志条目。当这条日志被复制到大多数服务器上，leader 向客户端返回结果。

日志由有序编号的日志条目组成。包含 被创建时的任期号（term），用于状态机执行的命令。如果一个日志被复制到大多数服务器上，就认为可以提交。

raft 日志同步保证一下两点

- 如果不同日志中的两个条目有着相同的索引和任期号，则他们所存储的命令是相同的。
- 如果不同日志中的两个条目有着相同的索引和任期号，则它们之前的所有条目都是相同的。

一般情况下， leader 和 followers 日志保持一致，但是当 leader 崩溃时，旧的 leader 可能没有完全复制完日志中的所有条目。可能会导致日志不一致。leader 通过强制复制 leader 日志条目给 followers 来消除不一致。

##### 安全性

- 拥有最新的已提交的 log entry 的 follower 才有资格成为 leader。（candidate 在发送 RequestVote RPC 时，要带上自己的最后一条日志的 term 和 log index。其它节点收到消息时，如果发现自己的日志条目更新，则拒绝投票）
- Leader 只能推进 commit index 来提交当前 term 的已经复制到大多数服务器上的日志，旧 term 日志的提交要等到提交当前 term 的日志来间接提交。

##### 日志压缩

snapshot 之前的日志都可以丢弃。

snapshot 中包括以下内容

- 日志元数据。
- 系统当前状态。

可以通过 copy-on-write 技术避免 snapshot 过程影响日志同步。

##### 成员变更

这也是一个分布式一致性问题，即所有服务器对新成员达成一致。成员变更的一致性达成的过程中，参与投票的过程会发生变化。

问题：可能选出两个 leader。

为了解决这一问题，raft 提出两阶段成员变更办法。

- Leader 收到成员变更请求从Cold 切成 Cnew。
- Leader 在本地生成一个新的 log entry，其内容是 Cold U Cnew，写入本地日志。同时将该 log entry 复制至 Cold U Cnew 的所有副本。新的日志同步需要保证得到 Cold 和 Cnew 两个多数派的确认。
- Follower 收到 Cold∪Cnew 的 log entry 后更新本地日志，并且此时就以该配置作为自己的成员配置。
- 如果 Cold 和 Cnew 中的两个多数派确认了 Cold U Cnew 这条日志，Leader 就提交这条 log entry；
- 接下来 Leader 生成一条新的 log entry，其内容是新成员配置 Cnew，同样将该 log entry 写入本地日志，同时复制到 Follower上；
- Follower 收到新成员配置 Cnew 后，将其写入日志，并且从此刻起，就以该配置作为自己的成员配置，并且如果发现自己不在 Cnew 这个成员配置中会自动退出。
- Leader 收到 Cnew 的多数派确认后，表示成员变更成功，后续的日志只要得到 Cnew 多数派确认即可。Leader 给客户端回复成员变更执行成功。



可从数学上严格证明，只要每次只允许增加或删除一个成员，Cold 与 Cnew 不可能形成两个不相交的多数派。两阶段可简化成为一阶段。

