#### linux 内核设计与实现

---



**进程**

​	进程就是处于执行期的程序。unix 的每个进程都有一个当前工作目录，它属于进程执行上下文，

​	线程是在进程中活动的对象，每个线程拥有一个独立的程序计数器、进程栈和一组进程寄存器。内核调度的对象是线程，而不是进程。

​	进程提供两种虚拟机制：虚拟处理器和虚拟内存。

​	进程创建：fork() 和 exec() 写时拷贝（fork() 调用了 clone() 函数）

内核把进程的列表存放在任务队列（双向循环链表）中，链表类型为 task_struct，称为进程描述符（大概1.7KB，包含了进程所需的所有信息）。

linux 通过 slab 分配器分配 task_struct 结构。



进程描述符的存放。

有专门的寄存器



进程状态

​	TASK_RUNNING（运行）、TASK_INTERRUPTIBLE（可中断）、TASK_UNINTERRUPTIBLE、_TASK_TRACED、TASK_STOPPED


线程创建和进程类似，只是在调用 clone 时需要传递一些参数标志来指明需要共享的资源。

clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND , 0)

表示父子共享地址空间，文件系统资源，文件描述符，信号处理程序



内核线程

独立运行在内核空间的标准进程。（没有独立的地址空间，只在内核态运行）



进程终结

exit() 系统调用

	1. 将 task_struct 中的标志成员设置为 PF_EXITING
	1. del_timer_sync() 删除任意内核定时器，确保没有定时器在排队
	1. 输出记账信息
	1. 调用 exit_mm() 释放进程占用的 mm_struct。
	1. 调用 sem_exit()
	1. 调用 exit_files 和 exit_fs()
	1. 退出代码置为由 do_exit() 提供的代码。
	1. 调用 exit_notify。向父进程发送信号，给子进程重新找养父，进程状态设为 exit_ZOMBIE。此时它所占有的只有 内核栈、thread_info、task_struct 结构了。
	1. do_exit() 切换到新的进程，do_exit() 永不返回。

删除进程描述符（调用 release_task)

父进程获得已终结的子进程信息，通知内核不再关注子进程信息后，task_struct 结构才被释放。



**调度程序**

调度程序是确保进程能有效工作的一个内核子系统。

多任务操作系统指能同时并发的交互执行多个进程的操作系统。

多任务系统可划分为两类：非抢占式任务和抢占式任务。



策略

IO 消耗型（缩短响应时间）和处理器消耗型的进程



基于优先级的调度

- 基于 nice 值。（-20 ~ +19）nice 值越大，优先级越低。
- 实时优先级。（0 ~ 99）可配置，值越大，优先级越高。



**linux 调度算法**

传统 unix 调度过程

优先级以 nice 值输送给用户空间

- 问题一。nice 值映射到时间片，意味着 nice 单位值要对应到处理器的绝对时间，导致进程切换无法最优化。
- 问题二。相对 nice 值。把进程的 nice 值减小1 所带来的效果极大的取决于原来的 nice 值。
- 问题三。绝对时间片在内核的测试范围中，意味着时间片必须是定时器节拍的整数倍。

**完全公平调度**（CFS）

在所有可运行进程总数的基础上，计算出一个进程应该运行多久（1/n)，循环轮转，选择运行最少的作为下一个运行进程。

不同 nice 值的情况。绝对 nice 值不再影响调度情况，相对 nice 值才会影响处理器时间的分配比例。



**linux 调度的实现**

**时间记账**

调度器实体结构

```cpp
struct sched_entity {
    ...
}
```

作为名为 se 的成员变量，嵌入在进程描述符 task_struct 内。

虚拟实时

vruntime 存放进程的虚拟运行时间(ns)。

进程选择

选择具有最小 vruntime 的进程。

CFS 使用红黑树来组织可运行进程队列。最左侧叶子节点即是具有最小 vruntime 的进程。

调度器入口（schedule())

它会找到一个最高优先级的调度类，它会调用 pick_next_task()，检查每一个调度类，并从调度类中选择最高优先级的进程。

睡眠和唤醒

休眠。进程把自己标记为休眠状态，从可执行红黑树中移出，放入等待队列。然后调用 schedule() 选择和执行一个其它线程。唤醒过程刚好相反。

休眠有两种相关进程状态。TASK_UNINTERRUPTIBLE 和 TASK_INTERRUPTIBLE 。两种状态的进程位于同一个等待队列上，等待某些事件，不能运行。

内核用 wake_queue_head_t 表示等待队列。当于等待队列相关的事件发生时，队列上的进程会被唤醒。

**等待队列**

```c
DEFINE_WAIT(wait); // 创建一个等待队列的项

add_wait_queue(q, &wait); // 把自己加入到等待队列中，必须在其它地方撰写相关代码，在事件发生时，对等待队列执行 wake_up() 操作
while(!condition) {	// condition 是我们等待的事件
    prepare_to_wait(&q, &wait, TASK_INTERRUPTIBLE); // 将进程状态变更为 TASK_INTERRUPTIBLE 或 TASK_UNINTERRUPTIBLE。
    if (signal_pending(current)) {
        // 处理信号
    }
    schedule();
}
finish_wait(&q, &wait);  // 把自己移出等待队列
```

唤醒

唤醒操作通过 `wake_up` 函数进行。它调用函数 try_to_wake_up() , 该函数负责将进程设置为 TASK_RUNNING 状态，调用 enqueue_task() 将此进程放入红黑树中。



抢占和上下文切换

上下文切换，也就是从一个可执行进程切换到另一个可执行进程。由定义在 kernel/sched.c 中的 context_switch() 函数负责处理。它完成两项基本工作：

- 调用 `<asm/mmu_context.h>` 中的 `switch_mm()` ，该函数负责把虚拟内存从上一个进程映射切换到新进程中。
- 调用 `<asm/system.h>` 中的 `switch_to()` ，切换进程处理器状态。包括保存、恢复栈信息和寄存器信息，还有其它任何与体系结构相关的信息，以进程为对象进行管理和保存。

need_rescheded 函数表明需要重新执行一次调度。

用户抢占

内核即将返回用户空间的时候，如果 `need_rescheded` 标志被设置，会导致 `schedule()` 被调用，此时就会发生用户抢占。

用户抢占在以下情况时发生：

- 从系统调用返回用户空间时
- 从中断处理程序返回用户空间时

内核抢占

linux 内核 2.6 之后支持内核抢占。只要没有持有锁，内核就可以进行抢占。

进程 thread_info 引入 preempt_count 计数器。使用锁，数值加一，释放锁，数值减一。preempt_count 减到 0，可以被抢占。

内核抢占发生在：

- 中断处理程序正在进行，且返回内核空间之前。
- 内核代码具有可抢占性的时候
- 内核中的任务显式的调用 `schedule()` 
- 如果内核中的任务阻塞。

**实时调度策略**

实时 SCHED_FIFO 和 SCHED_RR，非实时 SCHED_NORMAL

SCHED_FIFO 先入先出调度算法。处于可运行状态的 SCHED_FIFO 级的进程优先于 SCHED_NORMAL 级的进程，SCHED_FIFO 处于可执行状态就可以一直运行，它不基于时间片，直到被阻塞或被更高优先级的 SCHED_FIFO 进程 或 SCHED_NORMAL 进程抢占。

SCHED_RR 。是带有时间片的 SCHED_FIFO。时间片只用来重新调度同一优先级的进程。



**系统调用**



**中断和中断处理**

中断使得硬件得以发出通知给处理器。

异常与中断不同，它在产生时必须考虑与处理器时钟同步，实际上，异常也常被称为同步中断。



注册中断处理程序

中断处理程序是管理硬件的驱动程序的组成部分。每一设备都有相关的驱动程序，如果设备使用中断，则相应的驱动程序就注册一个中断处理程序。

驱动程序通过 `request_irq` 函数注册，并且激活给定的中断线，以处理中断。

一个中断例子

```c
request_irq();
if (request_irq(irqn, my_interrupt, IRQF_SHARED, "my_device", my_dev)) {
    printk(KERN_ERR "my device: cannot register IRQ %d\n", irqn);
    return EIO;
}
```

irqn 是请求的中断线，my_interrupt 是中断处理程序，通过标志设置中断线可以共享，设备命名为 my_device, 最后是传递 my_dev 变量给 dev 形参。

释放中断处理程序

卸载驱动程序时，需要注销相应的中断处理程序，并释放中断线。

```c
void free_irq(unsigned int irq, void *dev);
```

如果指定的中断线不是共享的，则该函数删除处理程序的同时要禁用中断线，否则，仅删除处理程序，这条中断线只有在删除最后一个处理程序后才被禁用。

编写中断处理程序

```c
static irqreturn_t intr_handler(int irq, void* dev) // 中断处理程序声明
```



文件操作

```c
struct file_operations {}
```

```c
int mmap(struct file *file, struct vm_area_struct *vma)
```

将函数给定的文件映射到指定的地址空间，由系统调用 mmap 调用它。



和文件系统相关的数据结构

file_system_type 用来描述特定文件系统类型。

```c
file_system_type {}
```

vfsmount 用来代表文件系统实例，也就是说，一个安装点。



由三个数据结构将 VFS 层和系统的进程紧密联系在一起。它们分别是 file_struct、fs_struct 和 namespace 结构体。



进程相关数据结构

```c
struct file_struct {
    atomic_t               count;		              /* 结构的使用计数 */
    struct fdtable         *fdt;                      /* 指向其它 fd 表的指针 */
    struct fdtable         fdtab;                     /* 基 fd 表 */
    spinlock_t             file_lock;                 /* 单个文件的锁 */
    int                    next_fd;                   /* 缓存下一个可用的 fd */
    struct embedded_fd_set close_on_exec_init;        /* exec()时关闭的文件描述符链表 */
    struct embedded_fd_set open_fds_init;             /* 打开的文件描述符链表 */
    struct file           *fd_array[NR_OPEN_DEFAULT]; /* 缺省的文件对象数组 */
};
```

fd_array 数组指向已打开的文件对象，默认可容纳 64 个文件对象。

```c
struct fs_struct {
    int         users;   /* 用户数目 */
    rwlock_t    lock;    /* 保护该结构体的锁 */
    int         umask;   /* 掩码 */
    int         in_exec; /* 当前正在执行的文件 */
    struct path root;    /* 根目录路径 */
    struct path pwd;     /* 当前工作目录的路径 */
};
```

该结构体包含了当前进程的当前工作目录（pwd）和根目录。

```c
struct mmt_namespace {
    atomic_t          count;    /* 结构的使用计数 */
    struct vfsmount   *root;    /* 根目录的安装点对象 */
    struct list_head  list;     /* 安装点链表 */
    wait_queue_head_t poll;     /* 轮询的等待队列 */
    int               event;    /* 事件计数 */
};
```



块 IO 层。

系统中能够**随机访问**固定大小数据片的硬件设备称作块设备，这些固定大小的数据片就称作块。块设备都是以安装文件系统的方式访问的。另一种基本的设备类型就是字符设备。字符设备按照字符流的方式被**有序访问**，像串口和键盘。

缓冲区头

```c
struct buffer_head {
    unsigned 			long b_state;		/* 缓冲区状态标志 */
    struct buffer_head  *b_this_page;	    /* 页面中的缓冲区 */
    struct page 		*b_page;		    /* 存储缓冲区的页面 */
    sector_t 			b_blocknr;			/* 起始块号 */
    size_t 				b_size;			    /* 映像的大小 */
    char 				*b_data;		    /* 页面内的数据指针 */
    struct block_device *b_bdev;	        /* 相关联的块设备 */
    bh_end_io_t 		*b_end_to;		    /* IO 完成方法 */
    void 				*b_private;			/* io 完成方法 */
    struct list_head 	b_assoc_buffers;	/* 相关的映射链表 */
    struct addres_space *b_assoc_map; 	    /* 相关的地址空间 */
    atomic_t 			b_count;			/* 缓冲区使用计数 */
}
```

缓冲区头的目的在于描述磁盘块和物理内存缓冲区之间的映射关系。

bio 结构体

```c
struct bio {
    sector_t 			bi_sector;			/* 磁盘上相关的扇区 */
    struct bio 			*bi_next;			/* 请求链表 */
    struct block_device *bi_bdev;			/* 相关的块设备 */
    unsigned long 		bi_flags;			/* 状态和命令标志 */
    unsigned long 		bi_rw;				/* 读还是写 */
    unsigned short		bi_vcnt;			/* bio_vecs 偏移的个数 */
    unsigned short		bi_idx;				/* bio_io_vect 的当前索引 */
    unsigned short 		bi_phys_segments;	/* 结合后的片段数目 */
    unsigned int 		bi_size;			/* I/O 计数 */
    unsigned int		bi_seg_front_size;	/* 第一个可合并的段大小 */
    unsigned int 		bi_seg_back_size;	/* 最后一个可合并的段大小 */
    unsigned int		bi_max_vecs;		/* bio_vecs 数目上限 */
    unsigned int 		bi_comp_cpu;		/* 结束 CPU */
    atomic_t 			bi_cnt;				/* 使用计数 */
    struct bio_vec		*bi_io_vec;			/* bio_vecs 链表 */
    bio_end_io_t		*bi_end_io;			/* I/O 完成方法 */
    void 				*bi_private;		/* 拥有者的私有方法 */
    bio_destructor_t	*bi_destructor;		/* 撤销方法 */
    struct bio_vec		bi_inline_vecs[0];	/* 内嵌 bio 向量 */
};
```

使用 bio 结构体的目的主要是代表正在现场执行的 I/O 操作，所以该结构体中的主要域都是用来管理相关信息的。

IO 向量

bi_io_vec 域指向一个 bio_vec 结构体数组。该结构体链表包含了一个特定 IO 操作所需要使用到的所有片段。

```c
struct bio_vec {
    /* 指向这个缓冲区所驻留的物理页 */
    struct page 	*bv_page;
    /* 这个缓冲区以字节为单位的大小 */
    unsigned int 	bv_len;
    /* 缓冲区所驻留的页中以字节为单位的偏移量 */
    unsigned int 	bv_offset;
};
```



IO 调度程序

IO 调度程序的工作是管理块设备的请求队列。有利于减少磁盘的寻址时间，从而提高全局吞吐量。

通过两种方法减少磁盘寻址空间：合并和排序。

linus 电梯

最终期限 IO 调度程序（减少请求饥饿现象）

预测 IO 调度程序

完全公正的排队 IO 调度程序（每一个提交 IO 的进程都有自己的队列）

空操作的 IO 调度程序（专为随机访问设备而设计的）



进程地址空间

内存区域可以包含各种内存对象，比如

- 可执行文件代码的内存映射，称为代码段（text section）
- 已初始化全局变量的内存映射，称为数据段（data section）
- 未初始化的全局变量，也就是 bss 段的零页的内存映射
- 进程用户空间栈的内存映射
- c 库或动态链接库的代码段数据段和 bss 段都会载入进程的地址空间
- 任何内存映射文件
- 任何共享内存段
- 任何匿名的内存映射，比如 malloc 分配的内存

内存描述符 mm_struct

```c
struct mm_struct {
    struct vm_area_struct 	*mmap;				/* 内存区域链表 */
    struct rb_root			mm_rb;				/* VMA 形成的红黑树 */
    struct vm_area_struct 	*mmap_cache;		/* 最近使用的内存区域 */
    unsigned long			free_area_cache;	/* 地址空间第一个空洞 */
    pgd_t					*pgd;				/* 页全局目录 */
    atomic_t				mm_users;			/* 使用地址空间的用户数 */
    atomic_t				mm_count;			/* 主使用计数器 */
    int						map_count;			/* 内存区域的个数 */
    struct rw_semaphore		mmap_sem;			/* 内存区域的信号量 */
    spinlock_t				page_table_lock;	/* 页表锁 */
    struct list_head		mmlist;				/* 所有 mm_struct 形成的链表 */
    unsigned long			start_code;			/* 代码段的开始地址 */
    unsigned long			end_code;			/* 代码段的结束地址 */
    unsigned long 			start_data;			/* 数据的首地址 */
    unsigned long			end_data;			/* 数据的尾地址 */
    unsigned long			start_brk;			/* 堆的首地址 */
    unsigned long			brk;				/* 堆的尾地址 */
    unsigned long 			start_stack;		/* 进程栈的首地址 */
    unsigned long			arg_start;			/* 命令行参数的首地址 */
    unsigned long 			arg_end;			/* 命令行参数的尾地址 */
    unsigned long			env_start;			/* 环境变量的首地址 */
    unsigned long			env_end;			/* 环境变量的尾地址 */
    unsigned long			rss;				/* 所分配的物理页 */
    unsigned long			total_vm;			/* 全部页面数目 */
    unsigned long			locked_vm;			/* 上锁的页面数目 */
    unsigned long			saved_auxv[AT_VECTOR_SIZE]; /* 保存的 auxv */
    cpumask_t				cpu_vm_mask;		/* 懒惰（lazy） TLB 交换掩码 */
    mm_context_t			context;			/* 体系结构特殊结构 */
    unsigned long 			flags;				/* 状态标志 */
    int 					core_waiters;		/* 内核转储等待线程 */
    struct core_state		*core_state;		/* 核心转储的支持 */
    spinlock_t				ioctx_lock;			/* AIO I/O 链表锁 */
    struct hlist_head		ioctx_list;			/* AIO I/O 链表 */
};
```

在进程描述符中（task_struct)，mm 域存放着该进程使用的内存描述符，current->mm 便指向当前进程的内存描述符。fork() 函数利用 copy_mm() 函数复制父进程的内存描述符，也就是 current->mm 域给其子进程，而子进程中的 mm_struct 结构体实际上是通过文件 kernel/fork.c 中的 allocate_mm() 宏从 mm_cachep_slab 缓存中分配得到的。



虚拟内存区域

```c
struct vm_area_struct {
    struct mm_struct 		*vm_mm;			/* 相关的 mm_struct 结构体 */
    unsigned long 			vm_start;		/* 区间的首地址 */
    unsigned long 			vm_end;			/* 区间的尾地址 */
    struct vm_area_struct 	*vm_next;		/* VMA 链表 */
    pgprot_t				vm_page_prot;	/* 访问控制权限 */
    unsigned long			vm_flags;		/* 标志 */
    struct rb_node			vm_rb;			/* 树上该 VMA 的节点 */
    union {	/* 或者是关联于 address_space->i_mmap 字段，或者是关联于 address_space->i_mmap_nonlinear 字段 */
        struct {
            struct list_head		list;
            void 					*parent;
            struct vm_area_struct	*head;
        } vm_set;
        struct prio_tree_node 		prio_tree_node;
    } shared;
    struct list_head			anon_vma_node;		/* anon_vma 项 */
    struct anon_vma				*anon_vma;			/* 匿名 VMA 对象 */
    struct vm_operations_struct	*vm_ops;			/* 相关的操作表 */
    unsigned long				vm_pgoff;			/* 文件中的偏移量 */
    struct file					*vm_file;			/* 被映射的文件（如果存在） */
    void						*vm_private_data;	/* 私有数据 */
};
```



mmap() 和 do_mmap()：创建地址区间

```c
unsigned long do_mmap(struct file *file, unsigned long addr, unsigned long len, unsigned long prot, unsigned long flag, unsigned long offset)
```

如果 file 参数是 NULL 并且 offset 参数是 0，就代表此次映射和文件没有关系，这种情况称作匿名映射。如果指定了文件名和偏移量，那么该映射称为文件映射。



mummap() 和 do_mmummap()：删除地址空间



页表

linux 中使用三级页表完成地址转换。

顶级页表是页全局目录（PGD），它包含一个 pgd_t 类型数组。PGD 中的表项指向二级页目录中的表项：PMD。

二级页表（PMD）是中间页目录，它是个 pmd_t 类型的数组。其中的表项指向 PTE 中的表项。

最后一级的页表简称页表。其中包含 pte_t 类型的数组，该页表项指向物理页面。

内存地址

逻辑地址（由 段（segment）和偏移量（offset 或 displacement）组成）

线性地址，也称虚拟地址。32 位无符号整数，4GB 地址空间



代码段描述符。可以放在 GDT 或 LDT 中，置 S 标志为 1（非系统段）。

数据段描述符。栈段是通过一般的数据段实现的。

任务状态段描述符。S 置为 0。

局部描述符表描述符。



页高速缓存和页回写

页高速缓存是 linux 内核实现磁盘缓存，主要用来减少对磁盘的 IO 操作。

写缓存

linux 采用回写。程序执行写操作直接写到缓存中，后端存储不会立刻直接更新，而是将页高速缓存中的页面标记成“脏”，并且加入到脏页链表中。然后由回写进程周期性将脏页链表中的页写回到磁盘，从而让磁盘中的数据和内存保存一致。

缓存回收

linux 的缓存回收是通过选择干净页（不脏）进行简单替换。

缓存回收策略

最近最少使用。简称 LRU。

双链策略。linux 维护的不再是一个 LRU 链表，而是两个链表，活跃链表和非活跃链表。



linux 页高速缓存

address_space 对象。物理地址对等体

```cc
struct address_space {
    struct inode 			*host;				/* 拥有节点 */
    struct radix_tree_root	page_tree;			/* 包含全部页面的 radix 树 */
    spinlock_t				tree_lock;			/* 保护 page_tree 的自旋锁 */
    unsigned int			i_mmap_writable;	/* VM_SHARED 的计数 */
    struct prio_tree_root	i_mmap;				/* 私有映射链表 */
    struct list_head		i_mmap_nonlinear;	/* VM_NONLINEAR 链表 */
    spinlock_t				i_mmap_lock;		/* 保护 i_mmap 的自旋锁 */
    atomic_t				truncate_count;		/* 截断计数 */
    unsigned long			nrpages;			/* 页总数 */
    pgoff_t					writeback_index;	/* 回写的起始偏移 */
    struct address_space_operations *a_ops;		/* 操作表 */
    unsigned long 			flags;				/* gfp_mask 掩码于错误标识 */
    struct backing_dev_info *backing_dev_info;	/* 预读信息 */
    spinlock_t				private_lock;		/* 私有 address_space 锁 */
    struct list_head		private_list;		/* 私有 address_space 链表 */
    struct address_space	*assoc_mapping;		/* 相关的缓冲 */
}
```

其中 i_mmap 字段是个优先搜索树。

页总数由 nrpages 字段描述。每个 address_space 对象都有唯一的基数(radix tree)，它保存在 page_tree 结构体中。

缓冲区高速缓存

flusher 线程将脏页写回磁盘。



设备与模块

